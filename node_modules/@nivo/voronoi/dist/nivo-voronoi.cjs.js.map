{"version":3,"file":"nivo-voronoi.cjs.js","sources":["../src/props.ts","../src/defaults.ts","../src/computeMesh.ts","../src/hooks.ts","../src/Voronoi.tsx","../src/ResponsiveVoronoi.tsx","../src/meshCanvas.ts","../src/Mesh.tsx"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Margin, defaultMargin as coreDefaultMargin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\n\nexport const defaultNodePositionAccessor = (node: {\n    x: number\n    y: number\n}): [x: number, y: number] => [node.x, node.y]\n\nexport const defaultMargin: Margin = coreDefaultMargin\n\nexport const defaultTooltipPosition: TooltipPosition = 'cursor'\nexport const defaultTooltipAnchor: TooltipAnchor = 'top'\n","import { Delaunay } from 'd3-delaunay'\nimport { Margin } from '@nivo/core'\nimport { NodePositionAccessor } from './types'\nimport { defaultNodePositionAccessor, defaultMargin } from './defaults'\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    margin = defaultMargin,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    margin?: Margin\n}): [number, number][] => {\n    return points.map(node => {\n        const [x, y] = getNodePosition(node)\n\n        return [x + margin.left, y + margin.top]\n    })\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly [number, number][]\n    width: number\n    height: number\n    margin?: Margin\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug\n        ? delaunay.voronoi([\n              0,\n              0,\n              margin.left + width + margin.right,\n              margin.top + height + margin.bottom,\n          ])\n        : undefined\n\n    return { points, delaunay, voronoi }\n}\n","import {\n    MouseEvent,\n    MutableRefObject,\n    TouchEvent,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n} from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { getDistance, getRelativeCursor, Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition, useTooltip } from '@nivo/tooltip'\nimport { computeMeshPoints, computeMesh } from './computeMesh'\nimport {\n    VoronoiCommonProps,\n    VoronoiDatum,\n    VoronoiCustomLayerProps,\n    NodeMouseHandler,\n    // DatumTouchHandler,\n    NodePositionAccessor,\n    NodeTouchHandler,\n} from './types'\nimport {\n    defaultMargin,\n    defaultNodePositionAccessor,\n    defaultTooltipPosition,\n    defaultTooltipAnchor,\n} from './defaults'\n\nexport const useVoronoiMesh = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    // Margins are added to the chart's dimensions, so that mouse detection\n    // also works inside the margins, omit if that's not what you want.\n    // When including the margins, we recommend to set a `detectionRadius` as well.\n    margin?: Margin\n    width: number\n    height: number\n    debug?: boolean\n}) =>\n    useMemo(\n        () =>\n            computeMesh({\n                points: computeMeshPoints<Node>({ points, margin, getNodePosition }),\n                width,\n                height,\n                margin,\n                debug,\n            }),\n        [getNodePosition, points, width, height, margin, debug]\n    )\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n\nexport const useMeshEvents = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    delaunay,\n    setCurrent: setCurrentNode,\n    margin = defaultMargin,\n    detectionRadius = Infinity,\n    isInteractive = true,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    delaunay: Delaunay<Node>\n    setCurrent?: (node: Node | null) => void\n    margin?: Margin\n    detectionRadius?: number\n    isInteractive?: boolean\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n}) => {\n    // Store the index of the current point and the current node.\n    const [current, setCurrent] = useState<[number, Node] | null>(null)\n\n    // Keep track of the previous index and node, this is needed as we don't have enter/leave events\n    // for each node because we use a single rect element to capture events.\n    const previous = useRef<[number, Node] | null>(null)\n\n    useEffect(() => {\n        previous.current = current\n    }, [previous, current])\n\n    const findNode = useCallback(\n        (event: MouseEvent<ElementType> | TouchEvent<ElementType>): null | [number, Node] => {\n            if (!elementRef.current || nodes.length === 0) return null\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n\n            let index: number | null = delaunay.find(x, y)\n            let node = index !== undefined ? nodes[index] : null\n\n            if (node && detectionRadius !== Infinity) {\n                const [nodeX, nodeY] = getNodePosition(node)\n                if (getDistance(x, y, nodeX + margin.left, nodeY + margin.top) > detectionRadius) {\n                    index = null\n                    node = null\n                }\n            }\n\n            if (index === null || node === null) return null\n\n            return [index, node]\n        },\n        [elementRef, delaunay, nodes, getNodePosition, margin, detectionRadius]\n    )\n\n    const { showTooltipAt, showTooltipFromEvent, hideTooltip } = useTooltip()\n    const showTooltip = useMemo(() => {\n        if (!tooltip) return undefined\n\n        if (tooltipPosition === 'cursor') {\n            // Following the cursor.\n            return (node: Node, event: MouseEvent<ElementType>) => {\n                showTooltipFromEvent(tooltip(node), event, tooltipAnchor)\n            }\n        }\n\n        // Fixed at the node's position.\n        return (node: Node) => {\n            const [x, y] = getNodePosition(node)\n            showTooltipAt(tooltip(node), [x + margin.left, y + margin.top], tooltipAnchor)\n        }\n    }, [\n        showTooltipAt,\n        showTooltipFromEvent,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n        getNodePosition,\n        margin,\n    ])\n\n    // Mouse enter only occurs when entering the main element,\n    // not for each node.\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n            setCurrentNode?.(match ? match[1] : null)\n\n            if (match) {\n                const node = match[1]\n\n                showTooltip?.(node, event)\n                onMouseEnter?.(match[1], event)\n            }\n        },\n        [findNode, setCurrent, setCurrentNode, showTooltip, onMouseEnter]\n    )\n\n    // Handle mouse enter/move/leave, relying on `previous` to simulate events.\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) {\n                const [index, node] = match\n\n                setCurrentNode?.(node)\n                showTooltip?.(node, event)\n\n                if (previous.current) {\n                    const [previousIndex, previousNode] = previous.current\n                    if (index !== previousIndex) {\n                        // Simulate an enter event if the previous index is different.\n                        onMouseLeave?.(previousNode, event)\n                    } else {\n                        // If it's the same, trigger a regular move event.\n                        onMouseMove?.(node, event)\n                    }\n                } else {\n                    onMouseEnter?.(node, event)\n                }\n            } else {\n                setCurrentNode?.(null)\n                hideTooltip?.()\n\n                if (previous.current) {\n                    // Simulate a leave event if there's a previous node.\n                    onMouseLeave?.(previous.current[1], event)\n                }\n            }\n        },\n        [\n            findNode,\n            setCurrent,\n            setCurrentNode,\n            previous,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            showTooltip,\n            hideTooltip,\n        ]\n    )\n\n    // Mouse leave only occurs when leaving the main element,\n    // not for each node.\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            setCurrent(null)\n            setCurrentNode?.(null)\n\n            hideTooltip()\n\n            if (onMouseLeave && previous.current) {\n                onMouseLeave(previous.current[1], event)\n            }\n        },\n        [setCurrent, setCurrentNode, previous, hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseDown?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseUp?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onDoubleClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchStart?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchMove?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrent(null)\n                setCurrentNode?.(null)\n            }\n\n            if (onTouchEnd && previous.current) {\n                onTouchEnd(previous.current[1], event)\n            }\n        },\n        [enableTouchCrosshair, setCurrent, setCurrentNode, onTouchEnd, previous]\n    )\n\n    return {\n        current,\n        handleMouseEnter: isInteractive ? handleMouseEnter : undefined,\n        handleMouseMove: isInteractive ? handleMouseMove : undefined,\n        handleMouseLeave: isInteractive ? handleMouseLeave : undefined,\n        handleMouseDown: isInteractive ? handleMouseDown : undefined,\n        handleMouseUp: isInteractive ? handleMouseUp : undefined,\n        handleClick: isInteractive ? handleClick : undefined,\n        handleDoubleClick: isInteractive ? handleDoubleClick : undefined,\n        handleTouchStart: isInteractive ? handleTouchStart : undefined,\n        handleTouchMove: isInteractive ? handleTouchMove : undefined,\n        handleTouchEnd: isInteractive ? handleTouchEnd : undefined,\n    }\n}\n\n/**\n * Compute a voronoi mesh and corresponding events.\n */\nexport const useMesh = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition,\n    width,\n    height,\n    margin = defaultMargin,\n    isInteractive = true,\n    detectionRadius = Infinity,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug = false,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    width: number\n    height: number\n    margin?: Margin\n    isInteractive?: boolean\n    detectionRadius?: number\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    debug?: boolean\n}) => {\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        current,\n    } = useMeshEvents<Node, ElementType>({\n        elementRef,\n        nodes,\n        margin,\n        setCurrent,\n        delaunay,\n        detectionRadius,\n        isInteractive,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    return {\n        delaunay,\n        voronoi,\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n    }\n}\n","import { createElement, Fragment, ReactNode, forwardRef, Ref } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'> & {\n        forwardedRef: Ref<SVGSVGElement>\n    }\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n    forwardedRef,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = forwardRef(\n    (\n        {\n            theme,\n            ...props\n        }: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n            Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container isInteractive={false} animate={false} theme={theme}>\n            <InnerVoronoi {...props} forwardedRef={ref} />\n        </Container>\n    )\n)\n","import { forwardRef, Ref } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = ResponsiveProps<\n    Partial<Omit<VoronoiSvgProps, 'data'>> & Pick<VoronoiSvgProps, 'data'>\n>\n\nexport const ResponsiveVoronoi = forwardRef(\n    (\n        { defaultWidth, defaultHeight, onResize, debounceResize, ...props }: ResponsiveVoronoiProps,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <Voronoi {...props} width={width} height={height} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n)\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderDelaunayPointsToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    delaunay: Delaunay<Delaunay.Point>,\n    radius: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.15\n    ctx.beginPath()\n    delaunay.renderPoints(ctx, radius)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'pink'\n    ctx.fill()\n\n    ctx.restore()\n}\n\nexport const renderDebugToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        delaunay,\n        voronoi,\n        detectionRadius,\n        index,\n    }: {\n        delaunay: Delaunay<Delaunay.Point>\n        voronoi: Voronoi<Delaunay.Point>\n        detectionRadius: number\n        index: number | null\n    }\n) => {\n    renderVoronoiToCanvas(ctx, voronoi)\n\n    if (detectionRadius < Infinity) {\n        renderDelaunayPointsToCanvas(ctx, delaunay, detectionRadius)\n    }\n\n    if (index !== null) {\n        renderVoronoiCellToCanvas(ctx, voronoi, index)\n    }\n}\n","import { useMemo, useRef } from 'react'\nimport { Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\nimport { useVoronoiMesh, useMeshEvents } from './hooks'\nimport { NodeMouseHandler, NodePositionAccessor, NodeTouchHandler } from './types'\nimport { defaultMargin, defaultTooltipAnchor, defaultTooltipPosition } from './defaults'\n\ninterface MeshProps<Node> {\n    nodes: Node[]\n    width: number\n    height: number\n    margin?: Margin\n    getNodePosition?: NodePositionAccessor<Node>\n    // Can be used in case you want to keep track of the current node externally,\n    // the current node being the last hovered node.\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    // Restrict the node detection to a given radius, default to `Infinity`.\n    detectionRadius?: number\n    // If specified, tooltips are going to be handled automatically.\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    // Display the voronoi mesh for debugging purpose.\n    debug?: boolean\n}\n\nexport const Mesh = <Node,>({\n    nodes,\n    width,\n    height,\n    margin = defaultMargin,\n    getNodePosition,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    detectionRadius = Infinity,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug,\n}: MeshProps<Node>) => {\n    const elementRef = useRef<SVGRectElement | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n    } = useMeshEvents<Node, SVGRectElement>({\n        elementRef,\n        nodes,\n        delaunay,\n        margin,\n        detectionRadius,\n        setCurrent,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        enableTouchCrosshair,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) return voronoi.render()\n        return undefined\n    }, [debug, voronoi])\n\n    return (\n        <g ref={elementRef} transform={`translate(${-margin.left},${-margin.top})`}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {detectionRadius < Infinity && (\n                        <path\n                            stroke=\"red\"\n                            strokeWidth={0.35}\n                            fill=\"none\"\n                            d={delaunay.renderPoints(undefined, detectionRadius)}\n                        />\n                    )}\n                    {/* highlight the current cell */}\n                    {current && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(current[0])} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={margin.left + width + margin.right}\n                height={margin.top + height + margin.bottom}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onMouseDown={handleMouseDown}\n                onMouseUp={handleMouseUp}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n                onDoubleClick={handleDoubleClick}\n            />\n        </g>\n    )\n}\n"],"names":["defaultVoronoiProps","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","defaultNodePositionAccessor","node","x","y","defaultMargin","coreDefaultMargin","defaultTooltipPosition","defaultTooltipAnchor","computeMeshPoints","_ref","points","_ref$getNodePosition","getNodePosition","_ref$margin","margin","map","_getNodePosition","left","top","computeMesh","_ref2","width","height","_ref2$margin","debug","delaunay","Delaunay","from","voronoi","right","bottom","undefined","useVoronoiMesh","useMemo","useVoronoi","data","xScale","scaleLinear","domain","range","yScale","d","p","useVoronoiLayerContext","_ref3","useMeshEvents","_ref4","elementRef","nodes","_ref4$getNodePosition","setCurrentNode","setCurrent","_ref4$margin","_ref4$detectionRadius","detectionRadius","Infinity","_ref4$isInteractive","isInteractive","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","onTouchEnd","_ref4$enableTouchCros","enableTouchCrosshair","tooltip","_ref4$tooltipPosition","tooltipPosition","_ref4$tooltipAnchor","tooltipAnchor","_useState","useState","current","previous","useRef","useEffect","findNode","useCallback","event","length","_getRelativeCursor","getRelativeCursor","index","find","nodeX","nodeY","getDistance","_useTooltip","useTooltip","showTooltipAt","showTooltipFromEvent","hideTooltip","showTooltip","_getNodePosition2","handleMouseEnter","match","handleMouseMove","_previous$current","previousIndex","previousNode","handleMouseLeave","handleMouseDown","handleMouseUp","handleClick","handleDoubleClick","handleTouchStart","handleTouchMove","handleTouchEnd","InnerVoronoi","partialMargin","_ref$layers","_ref$xDomain","_ref$yDomain","_ref$enableLinks","_ref$linkLineWidth","_ref$linkLineColor","_ref$enableCells","_ref$cellLineWidth","_ref$cellLineColor","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$role","forwardedRef","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useVoronoi","layerById","links","cells","bounds","includes","_jsx","jsx","stroke","strokeWidth","fill","render","renderPoints","renderBounds","layerContext","SvgWrapper","ref","children","layer","i","Fragment","createElement","Voronoi","forwardRef","theme","props","_objectWithoutPropertiesLoose","_excluded","Container","animate","_extends","ResponsiveVoronoi","defaultWidth","defaultHeight","onResize","debounceResize","ResponsiveWrapper","renderVoronoiToCanvas","ctx","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderDelaunayPointsToCanvas","radius","renderVoronoiCellToCanvas","renderCell","fillStyle","_ref$enableTouchCross","_ref$detectionRadius","_ref$tooltipPosition","_ref$tooltipAnchor","_useVoronoiMesh","_useMeshEvents","voronoiPath","_jsxs","transform","_Fragment","opacity","style","cursor","_ref5","_ref5$margin","_ref5$isInteractive","_ref5$detectionRadius","_ref5$tooltipPosition","_ref5$tooltipAnchor","_ref5$debug"],"mappings":"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"}