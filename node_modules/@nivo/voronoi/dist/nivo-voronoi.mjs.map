{"version":3,"file":"nivo-voronoi.mjs","sources":["../src/props.ts","../src/defaults.ts","../src/computeMesh.ts","../src/hooks.ts","../src/Voronoi.tsx","../src/ResponsiveVoronoi.tsx","../src/Mesh.tsx","../src/meshCanvas.ts"],"sourcesContent":["import { VoronoiDomain, VoronoiLayer } from './types'\n\nexport const defaultVoronoiProps = {\n    xDomain: [0, 1] as VoronoiDomain,\n    yDomain: [0, 1] as VoronoiDomain,\n    layers: ['links', 'cells', 'points', 'bounds'] as VoronoiLayer[],\n    enableLinks: false,\n    linkLineWidth: 1,\n    linkLineColor: '#bbbbbb',\n    enableCells: true,\n    cellLineWidth: 2,\n    cellLineColor: '#000000',\n    enablePoints: true,\n    pointSize: 4,\n    pointColor: '#666666',\n    role: 'img',\n}\n","import { Margin, defaultMargin as coreDefaultMargin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\n\nexport const defaultNodePositionAccessor = (node: {\n    x: number\n    y: number\n}): [x: number, y: number] => [node.x, node.y]\n\nexport const defaultMargin: Margin = coreDefaultMargin\n\nexport const defaultTooltipPosition: TooltipPosition = 'cursor'\nexport const defaultTooltipAnchor: TooltipAnchor = 'top'\n","import { Delaunay } from 'd3-delaunay'\nimport { Margin } from '@nivo/core'\nimport { NodePositionAccessor } from './types'\nimport { defaultNodePositionAccessor, defaultMargin } from './defaults'\n\n/**\n * The delaunay generator requires an array\n * where each point is defined as an array\n * of 2 elements: [x: number, y: number].\n *\n * Points represent the raw input data\n * and x/y represent accessors to x & y.\n */\nexport const computeMeshPoints = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    margin = defaultMargin,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    margin?: Margin\n}): [number, number][] => {\n    return points.map(node => {\n        const [x, y] = getNodePosition(node)\n\n        return [x + margin.left, y + margin.top]\n    })\n}\n\nexport const computeMesh = ({\n    points,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly [number, number][]\n    width: number\n    height: number\n    margin?: Margin\n    debug?: boolean\n}) => {\n    const delaunay = Delaunay.from(points)\n    const voronoi = debug\n        ? delaunay.voronoi([\n              0,\n              0,\n              margin.left + width + margin.right,\n              margin.top + height + margin.bottom,\n          ])\n        : undefined\n\n    return { points, delaunay, voronoi }\n}\n","import {\n    MouseEvent,\n    MutableRefObject,\n    TouchEvent,\n    useCallback,\n    useEffect,\n    useMemo,\n    useRef,\n    useState,\n} from 'react'\nimport { scaleLinear } from 'd3-scale'\nimport { Delaunay } from 'd3-delaunay'\nimport { getDistance, getRelativeCursor, Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition, useTooltip } from '@nivo/tooltip'\nimport { computeMeshPoints, computeMesh } from './computeMesh'\nimport {\n    VoronoiCommonProps,\n    VoronoiDatum,\n    VoronoiCustomLayerProps,\n    NodeMouseHandler,\n    // DatumTouchHandler,\n    NodePositionAccessor,\n    NodeTouchHandler,\n} from './types'\nimport {\n    defaultMargin,\n    defaultNodePositionAccessor,\n    defaultTooltipPosition,\n    defaultTooltipAnchor,\n} from './defaults'\n\nexport const useVoronoiMesh = <Node>({\n    points,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    width,\n    height,\n    margin = defaultMargin,\n    debug,\n}: {\n    points: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    // Margins are added to the chart's dimensions, so that mouse detection\n    // also works inside the margins, omit if that's not what you want.\n    // When including the margins, we recommend to set a `detectionRadius` as well.\n    margin?: Margin\n    width: number\n    height: number\n    debug?: boolean\n}) =>\n    useMemo(\n        () =>\n            computeMesh({\n                points: computeMeshPoints<Node>({ points, margin, getNodePosition }),\n                width,\n                height,\n                margin,\n                debug,\n            }),\n        [getNodePosition, points, width, height, margin, debug]\n    )\n\nexport const useVoronoi = ({\n    data,\n    width,\n    height,\n    xDomain,\n    yDomain,\n}: {\n    data: VoronoiDatum[]\n    width: number\n    height: number\n    xDomain: VoronoiCommonProps['xDomain']\n    yDomain: VoronoiCommonProps['yDomain']\n}) => {\n    const xScale = useMemo(() => scaleLinear().domain(xDomain).range([0, width]), [xDomain, width])\n    const yScale = useMemo(\n        () => scaleLinear().domain(yDomain).range([0, height]),\n        [yDomain, height]\n    )\n\n    const points = useMemo(\n        () =>\n            data.map(d => ({\n                x: xScale(d.x),\n                y: yScale(d.y),\n                data: d,\n            })),\n        [data, xScale, yScale]\n    )\n\n    return useMemo(() => {\n        const delaunay = Delaunay.from(points.map(p => [p.x, p.y]))\n        const voronoi = delaunay.voronoi([0, 0, width, height])\n\n        return {\n            points,\n            delaunay,\n            voronoi,\n        }\n    }, [points, width, height])\n}\n\n/**\n * Memoize the context to pass to custom layers.\n */\nexport const useVoronoiLayerContext = ({\n    points,\n    delaunay,\n    voronoi,\n}: VoronoiCustomLayerProps): VoronoiCustomLayerProps =>\n    useMemo(\n        () => ({\n            points,\n            delaunay,\n            voronoi,\n        }),\n        [points, delaunay, voronoi]\n    )\n\nexport const useMeshEvents = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition = defaultNodePositionAccessor as NodePositionAccessor<Node>,\n    delaunay,\n    setCurrent: setCurrentNode,\n    margin = defaultMargin,\n    detectionRadius = Infinity,\n    isInteractive = true,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    delaunay: Delaunay<Node>\n    setCurrent?: (node: Node | null) => void\n    margin?: Margin\n    detectionRadius?: number\n    isInteractive?: boolean\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n}) => {\n    // Store the index of the current point and the current node.\n    const [current, setCurrent] = useState<[number, Node] | null>(null)\n\n    // Keep track of the previous index and node, this is needed as we don't have enter/leave events\n    // for each node because we use a single rect element to capture events.\n    const previous = useRef<[number, Node] | null>(null)\n\n    useEffect(() => {\n        previous.current = current\n    }, [previous, current])\n\n    const findNode = useCallback(\n        (event: MouseEvent<ElementType> | TouchEvent<ElementType>): null | [number, Node] => {\n            if (!elementRef.current || nodes.length === 0) return null\n\n            const [x, y] = getRelativeCursor(elementRef.current, event)\n\n            let index: number | null = delaunay.find(x, y)\n            let node = index !== undefined ? nodes[index] : null\n\n            if (node && detectionRadius !== Infinity) {\n                const [nodeX, nodeY] = getNodePosition(node)\n                if (getDistance(x, y, nodeX + margin.left, nodeY + margin.top) > detectionRadius) {\n                    index = null\n                    node = null\n                }\n            }\n\n            if (index === null || node === null) return null\n\n            return [index, node]\n        },\n        [elementRef, delaunay, nodes, getNodePosition, margin, detectionRadius]\n    )\n\n    const { showTooltipAt, showTooltipFromEvent, hideTooltip } = useTooltip()\n    const showTooltip = useMemo(() => {\n        if (!tooltip) return undefined\n\n        if (tooltipPosition === 'cursor') {\n            // Following the cursor.\n            return (node: Node, event: MouseEvent<ElementType>) => {\n                showTooltipFromEvent(tooltip(node), event, tooltipAnchor)\n            }\n        }\n\n        // Fixed at the node's position.\n        return (node: Node) => {\n            const [x, y] = getNodePosition(node)\n            showTooltipAt(tooltip(node), [x + margin.left, y + margin.top], tooltipAnchor)\n        }\n    }, [\n        showTooltipAt,\n        showTooltipFromEvent,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n        getNodePosition,\n        margin,\n    ])\n\n    // Mouse enter only occurs when entering the main element,\n    // not for each node.\n    const handleMouseEnter = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n            setCurrentNode?.(match ? match[1] : null)\n\n            if (match) {\n                const node = match[1]\n\n                showTooltip?.(node, event)\n                onMouseEnter?.(match[1], event)\n            }\n        },\n        [findNode, setCurrent, setCurrentNode, showTooltip, onMouseEnter]\n    )\n\n    // Handle mouse enter/move/leave, relying on `previous` to simulate events.\n    const handleMouseMove = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) {\n                const [index, node] = match\n\n                setCurrentNode?.(node)\n                showTooltip?.(node, event)\n\n                if (previous.current) {\n                    const [previousIndex, previousNode] = previous.current\n                    if (index !== previousIndex) {\n                        // Simulate an enter event if the previous index is different.\n                        onMouseLeave?.(previousNode, event)\n                    } else {\n                        // If it's the same, trigger a regular move event.\n                        onMouseMove?.(node, event)\n                    }\n                } else {\n                    onMouseEnter?.(node, event)\n                }\n            } else {\n                setCurrentNode?.(null)\n                hideTooltip?.()\n\n                if (previous.current) {\n                    // Simulate a leave event if there's a previous node.\n                    onMouseLeave?.(previous.current[1], event)\n                }\n            }\n        },\n        [\n            findNode,\n            setCurrent,\n            setCurrentNode,\n            previous,\n            onMouseEnter,\n            onMouseMove,\n            onMouseLeave,\n            showTooltip,\n            hideTooltip,\n        ]\n    )\n\n    // Mouse leave only occurs when leaving the main element,\n    // not for each node.\n    const handleMouseLeave = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            setCurrent(null)\n            setCurrentNode?.(null)\n\n            hideTooltip()\n\n            if (onMouseLeave && previous.current) {\n                onMouseLeave(previous.current[1], event)\n            }\n        },\n        [setCurrent, setCurrentNode, previous, hideTooltip, onMouseLeave]\n    )\n\n    const handleMouseDown = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseDown?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseDown]\n    )\n\n    const handleMouseUp = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onMouseUp?.(match[1], event)\n        },\n        [findNode, setCurrent, onMouseUp]\n    )\n\n    const handleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onClick]\n    )\n\n    const handleDoubleClick = useCallback(\n        (event: MouseEvent<ElementType>) => {\n            const match = findNode(event)\n\n            setCurrent(match)\n\n            if (match) onDoubleClick?.(match[1], event)\n        },\n        [findNode, setCurrent, onDoubleClick]\n    )\n\n    const handleTouchStart = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchStart?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchStart]\n    )\n\n    const handleTouchMove = useCallback(\n        (event: TouchEvent<ElementType>) => {\n            const match = findNode(event)\n\n            if (enableTouchCrosshair) {\n                setCurrent(match)\n                setCurrentNode?.(match ? match[1] : null)\n            }\n\n            if (match) onTouchMove?.(match[1], event)\n        },\n        [findNode, setCurrent, setCurrentNode, enableTouchCrosshair, onTouchMove]\n    )\n\n    const handleTouchEnd = useCallback(\n        (event: TouchEvent<SVGRectElement>) => {\n            if (enableTouchCrosshair) {\n                setCurrent(null)\n                setCurrentNode?.(null)\n            }\n\n            if (onTouchEnd && previous.current) {\n                onTouchEnd(previous.current[1], event)\n            }\n        },\n        [enableTouchCrosshair, setCurrent, setCurrentNode, onTouchEnd, previous]\n    )\n\n    return {\n        current,\n        handleMouseEnter: isInteractive ? handleMouseEnter : undefined,\n        handleMouseMove: isInteractive ? handleMouseMove : undefined,\n        handleMouseLeave: isInteractive ? handleMouseLeave : undefined,\n        handleMouseDown: isInteractive ? handleMouseDown : undefined,\n        handleMouseUp: isInteractive ? handleMouseUp : undefined,\n        handleClick: isInteractive ? handleClick : undefined,\n        handleDoubleClick: isInteractive ? handleDoubleClick : undefined,\n        handleTouchStart: isInteractive ? handleTouchStart : undefined,\n        handleTouchMove: isInteractive ? handleTouchMove : undefined,\n        handleTouchEnd: isInteractive ? handleTouchEnd : undefined,\n    }\n}\n\n/**\n * Compute a voronoi mesh and corresponding events.\n */\nexport const useMesh = <Node, ElementType extends Element>({\n    elementRef,\n    nodes,\n    getNodePosition,\n    width,\n    height,\n    margin = defaultMargin,\n    isInteractive = true,\n    detectionRadius = Infinity,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug = false,\n}: {\n    elementRef: MutableRefObject<ElementType | null>\n    nodes: readonly Node[]\n    getNodePosition?: NodePositionAccessor<Node>\n    width: number\n    height: number\n    margin?: Margin\n    isInteractive?: boolean\n    detectionRadius?: number\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    debug?: boolean\n}) => {\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        current,\n    } = useMeshEvents<Node, ElementType>({\n        elementRef,\n        nodes,\n        margin,\n        setCurrent,\n        delaunay,\n        detectionRadius,\n        isInteractive,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    return {\n        delaunay,\n        voronoi,\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n    }\n}\n","import { createElement, Fragment, ReactNode, forwardRef, Ref } from 'react'\nimport { Container, SvgWrapper, useDimensions } from '@nivo/core'\nimport { VoronoiSvgProps, VoronoiLayerId } from './types'\nimport { defaultVoronoiProps } from './props'\nimport { useVoronoi, useVoronoiLayerContext } from './hooks'\n\ntype InnerVoronoiProps = Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n    Pick<VoronoiSvgProps, 'data' | 'width' | 'height'> & {\n        forwardedRef: Ref<SVGSVGElement>\n    }\n\nconst InnerVoronoi = ({\n    data,\n    width,\n    height,\n    margin: partialMargin,\n    layers = defaultVoronoiProps.layers,\n    xDomain = defaultVoronoiProps.xDomain,\n    yDomain = defaultVoronoiProps.yDomain,\n    enableLinks = defaultVoronoiProps.enableLinks,\n    linkLineWidth = defaultVoronoiProps.linkLineWidth,\n    linkLineColor = defaultVoronoiProps.linkLineColor,\n    enableCells = defaultVoronoiProps.enableCells,\n    cellLineWidth = defaultVoronoiProps.cellLineWidth,\n    cellLineColor = defaultVoronoiProps.cellLineColor,\n    enablePoints = defaultVoronoiProps.enableCells,\n    pointSize = defaultVoronoiProps.pointSize,\n    pointColor = defaultVoronoiProps.pointColor,\n    role = defaultVoronoiProps.role,\n    forwardedRef,\n}: InnerVoronoiProps) => {\n    const { outerWidth, outerHeight, margin, innerWidth, innerHeight } = useDimensions(\n        width,\n        height,\n        partialMargin\n    )\n\n    const { points, delaunay, voronoi } = useVoronoi({\n        data,\n        width: innerWidth,\n        height: innerHeight,\n        xDomain,\n        yDomain,\n    })\n\n    const layerById: Record<VoronoiLayerId, ReactNode> = {\n        links: null,\n        cells: null,\n        points: null,\n        bounds: null,\n    }\n\n    if (enableLinks && layers.includes('links')) {\n        layerById.links = (\n            <path\n                key=\"links\"\n                stroke={linkLineColor}\n                strokeWidth={linkLineWidth}\n                fill=\"none\"\n                d={delaunay.render()}\n            />\n        )\n    }\n\n    if (enableCells && layers.includes('cells')) {\n        layerById.cells = (\n            <path\n                key=\"cells\"\n                d={voronoi.render()}\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n            />\n        )\n    }\n\n    if (enablePoints && layers.includes('points')) {\n        layerById.points = (\n            <path\n                key=\"points\"\n                stroke=\"none\"\n                fill={pointColor}\n                d={delaunay.renderPoints(undefined, pointSize / 2)}\n            />\n        )\n    }\n\n    if (layers.includes('bounds')) {\n        layerById.bounds = (\n            <path\n                key=\"bounds\"\n                fill=\"none\"\n                stroke={cellLineColor}\n                strokeWidth={cellLineWidth}\n                d={voronoi.renderBounds()}\n            />\n        )\n    }\n\n    const layerContext = useVoronoiLayerContext({\n        points,\n        delaunay,\n        voronoi,\n    })\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={margin}\n            role={role}\n            ref={forwardedRef}\n        >\n            {layers.map((layer, i) => {\n                if (layerById[layer as VoronoiLayerId] !== undefined) {\n                    return layerById[layer as VoronoiLayerId]\n                }\n\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, layerContext)}</Fragment>\n                }\n\n                return null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const Voronoi = forwardRef(\n    (\n        {\n            theme,\n            ...props\n        }: Partial<Omit<VoronoiSvgProps, 'data' | 'width' | 'height'>> &\n            Pick<VoronoiSvgProps, 'data' | 'width' | 'height'>,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <Container isInteractive={false} animate={false} theme={theme}>\n            <InnerVoronoi {...props} forwardedRef={ref} />\n        </Container>\n    )\n)\n","import { forwardRef, Ref } from 'react'\nimport { ResponsiveWrapper, ResponsiveProps } from '@nivo/core'\nimport { VoronoiSvgProps } from './types'\nimport { Voronoi } from './Voronoi'\n\ntype ResponsiveVoronoiProps = ResponsiveProps<\n    Partial<Omit<VoronoiSvgProps, 'data'>> & Pick<VoronoiSvgProps, 'data'>\n>\n\nexport const ResponsiveVoronoi = forwardRef(\n    (\n        { defaultWidth, defaultHeight, onResize, debounceResize, ...props }: ResponsiveVoronoiProps,\n        ref: Ref<SVGSVGElement>\n    ) => (\n        <ResponsiveWrapper\n            defaultWidth={defaultWidth}\n            defaultHeight={defaultHeight}\n            onResize={onResize}\n            debounceResize={debounceResize}\n        >\n            {({ width, height }: { width: number; height: number }) => (\n                <Voronoi {...props} width={width} height={height} ref={ref} />\n            )}\n        </ResponsiveWrapper>\n    )\n)\n","import { useMemo, useRef } from 'react'\nimport { Margin } from '@nivo/core'\nimport { TooltipAnchor, TooltipPosition } from '@nivo/tooltip'\nimport { useVoronoiMesh, useMeshEvents } from './hooks'\nimport { NodeMouseHandler, NodePositionAccessor, NodeTouchHandler } from './types'\nimport { defaultMargin, defaultTooltipAnchor, defaultTooltipPosition } from './defaults'\n\ninterface MeshProps<Node> {\n    nodes: Node[]\n    width: number\n    height: number\n    margin?: Margin\n    getNodePosition?: NodePositionAccessor<Node>\n    // Can be used in case you want to keep track of the current node externally,\n    // the current node being the last hovered node.\n    setCurrent?: (node: Node | null) => void\n    onMouseEnter?: NodeMouseHandler<Node>\n    onMouseMove?: NodeMouseHandler<Node>\n    onMouseLeave?: NodeMouseHandler<Node>\n    onMouseDown?: NodeMouseHandler<Node>\n    onMouseUp?: NodeMouseHandler<Node>\n    onClick?: NodeMouseHandler<Node>\n    onDoubleClick?: NodeMouseHandler<Node>\n    onTouchStart?: NodeTouchHandler<Node>\n    onTouchMove?: NodeTouchHandler<Node>\n    onTouchEnd?: NodeTouchHandler<Node>\n    enableTouchCrosshair?: boolean\n    // Restrict the node detection to a given radius, default to `Infinity`.\n    detectionRadius?: number\n    // If specified, tooltips are going to be handled automatically.\n    tooltip?: (node: Node) => JSX.Element\n    tooltipPosition?: TooltipPosition\n    tooltipAnchor?: TooltipAnchor\n    // Display the voronoi mesh for debugging purpose.\n    debug?: boolean\n}\n\nexport const Mesh = <Node,>({\n    nodes,\n    width,\n    height,\n    margin = defaultMargin,\n    getNodePosition,\n    setCurrent,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onMouseDown,\n    onMouseUp,\n    onClick,\n    onDoubleClick,\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    enableTouchCrosshair = false,\n    detectionRadius = Infinity,\n    tooltip,\n    tooltipPosition = defaultTooltipPosition,\n    tooltipAnchor = defaultTooltipAnchor,\n    debug,\n}: MeshProps<Node>) => {\n    const elementRef = useRef<SVGRectElement | null>(null)\n\n    const { delaunay, voronoi } = useVoronoiMesh<Node>({\n        points: nodes,\n        getNodePosition,\n        width,\n        height,\n        margin,\n        debug,\n    })\n\n    const {\n        current,\n        handleMouseEnter,\n        handleMouseMove,\n        handleMouseLeave,\n        handleMouseDown,\n        handleMouseUp,\n        handleClick,\n        handleDoubleClick,\n        handleTouchStart,\n        handleTouchMove,\n        handleTouchEnd,\n    } = useMeshEvents<Node, SVGRectElement>({\n        elementRef,\n        nodes,\n        delaunay,\n        margin,\n        detectionRadius,\n        setCurrent,\n        onMouseEnter,\n        onMouseMove,\n        onMouseLeave,\n        onMouseDown,\n        onMouseUp,\n        onClick,\n        onDoubleClick,\n        onTouchStart,\n        onTouchMove,\n        onTouchEnd,\n        enableTouchCrosshair,\n        tooltip,\n        tooltipPosition,\n        tooltipAnchor,\n    })\n\n    const voronoiPath = useMemo(() => {\n        if (debug && voronoi) return voronoi.render()\n        return undefined\n    }, [debug, voronoi])\n\n    return (\n        <g ref={elementRef} transform={`translate(${-margin.left},${-margin.top})`}>\n            {debug && voronoi && (\n                <>\n                    <path d={voronoiPath} stroke=\"red\" strokeWidth={1} opacity={0.75} />\n                    {detectionRadius < Infinity && (\n                        <path\n                            stroke=\"red\"\n                            strokeWidth={0.35}\n                            fill=\"none\"\n                            d={delaunay.renderPoints(undefined, detectionRadius)}\n                        />\n                    )}\n                    {/* highlight the current cell */}\n                    {current && (\n                        <path fill=\"pink\" opacity={0.35} d={voronoi.renderCell(current[0])} />\n                    )}\n                </>\n            )}\n            {/* transparent rect to intercept mouse events */}\n            <rect\n                data-ref=\"mesh-interceptor\"\n                width={margin.left + width + margin.right}\n                height={margin.top + height + margin.bottom}\n                fill=\"red\"\n                opacity={0}\n                style={{ cursor: 'auto' }}\n                onMouseEnter={handleMouseEnter}\n                onMouseMove={handleMouseMove}\n                onMouseLeave={handleMouseLeave}\n                onMouseDown={handleMouseDown}\n                onMouseUp={handleMouseUp}\n                onTouchStart={handleTouchStart}\n                onTouchMove={handleTouchMove}\n                onTouchEnd={handleTouchEnd}\n                onClick={handleClick}\n                onDoubleClick={handleDoubleClick}\n            />\n        </g>\n    )\n}\n","import { Delaunay, Voronoi } from 'd3-delaunay'\n\nexport const renderVoronoiToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.75\n    ctx.beginPath()\n    voronoi.render(ctx)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderDelaunayPointsToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    delaunay: Delaunay<Delaunay.Point>,\n    radius: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.15\n    ctx.beginPath()\n    delaunay.renderPoints(ctx, radius)\n    ctx.strokeStyle = 'red'\n    ctx.lineWidth = 1\n    ctx.stroke()\n\n    ctx.restore()\n}\n\nexport const renderVoronoiCellToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    voronoi: Voronoi<Delaunay.Point>,\n    index: number\n) => {\n    ctx.save()\n\n    ctx.globalAlpha = 0.35\n    ctx.beginPath()\n    voronoi.renderCell(index, ctx)\n    ctx.fillStyle = 'pink'\n    ctx.fill()\n\n    ctx.restore()\n}\n\nexport const renderDebugToCanvas = (\n    ctx: CanvasRenderingContext2D,\n    {\n        delaunay,\n        voronoi,\n        detectionRadius,\n        index,\n    }: {\n        delaunay: Delaunay<Delaunay.Point>\n        voronoi: Voronoi<Delaunay.Point>\n        detectionRadius: number\n        index: number | null\n    }\n) => {\n    renderVoronoiToCanvas(ctx, voronoi)\n\n    if (detectionRadius < Infinity) {\n        renderDelaunayPointsToCanvas(ctx, delaunay, detectionRadius)\n    }\n\n    if (index !== null) {\n        renderVoronoiCellToCanvas(ctx, voronoi, index)\n    }\n}\n"],"names":["defaultVoronoiProps","xDomain","yDomain","layers","enableLinks","linkLineWidth","linkLineColor","enableCells","cellLineWidth","cellLineColor","enablePoints","pointSize","pointColor","role","defaultNodePositionAccessor","node","x","y","defaultMargin","coreDefaultMargin","defaultTooltipPosition","defaultTooltipAnchor","computeMeshPoints","_ref","points","_ref$getNodePosition","getNodePosition","_ref$margin","margin","map","_getNodePosition","left","top","computeMesh","_ref2","width","height","_ref2$margin","debug","delaunay","Delaunay","from","voronoi","right","bottom","undefined","useVoronoiMesh","useMemo","useVoronoi","data","xScale","scaleLinear","domain","range","yScale","d","p","useVoronoiLayerContext","_ref3","useMeshEvents","_ref4","elementRef","nodes","_ref4$getNodePosition","setCurrentNode","setCurrent","_ref4$margin","_ref4$detectionRadius","detectionRadius","Infinity","_ref4$isInteractive","isInteractive","onMouseEnter","onMouseMove","onMouseLeave","onMouseDown","onMouseUp","onClick","onDoubleClick","onTouchStart","onTouchMove","onTouchEnd","_ref4$enableTouchCros","enableTouchCrosshair","tooltip","_ref4$tooltipPosition","tooltipPosition","_ref4$tooltipAnchor","tooltipAnchor","_useState","useState","current","previous","useRef","useEffect","findNode","useCallback","event","length","_getRelativeCursor","getRelativeCursor","index","find","nodeX","nodeY","getDistance","_useTooltip","useTooltip","showTooltipAt","showTooltipFromEvent","hideTooltip","showTooltip","_getNodePosition2","handleMouseEnter","match","handleMouseMove","_previous$current","previousIndex","previousNode","handleMouseLeave","handleMouseDown","handleMouseUp","handleClick","handleDoubleClick","handleTouchStart","handleTouchMove","handleTouchEnd","useMesh","_ref5","_ref5$margin","_ref5$isInteractive","_ref5$detectionRadius","_ref5$tooltipPosition","_ref5$tooltipAnchor","_ref5$debug","_useVoronoiMesh","_useMeshEvents","InnerVoronoi","partialMargin","_ref$layers","_ref$xDomain","_ref$yDomain","_ref$enableLinks","_ref$linkLineWidth","_ref$linkLineColor","_ref$enableCells","_ref$cellLineWidth","_ref$cellLineColor","_ref$enablePoints","_ref$pointSize","_ref$pointColor","_ref$role","forwardedRef","_useDimensions","useDimensions","outerWidth","outerHeight","innerWidth","innerHeight","_useVoronoi","layerById","links","cells","bounds","includes","_jsx","stroke","strokeWidth","fill","render","renderPoints","renderBounds","layerContext","SvgWrapper","ref","children","layer","i","Fragment","createElement","Voronoi","forwardRef","theme","props","_objectWithoutPropertiesLoose","_excluded","Container","animate","_extends","ResponsiveVoronoi","defaultWidth","defaultHeight","onResize","debounceResize","ResponsiveWrapper","Mesh","_ref$enableTouchCross","_ref$detectionRadius","_ref$tooltipPosition","_ref$tooltipAnchor","voronoiPath","_jsxs","transform","_Fragment","opacity","renderCell","style","cursor","renderVoronoiToCanvas","ctx","save","globalAlpha","beginPath","strokeStyle","lineWidth","restore","renderDelaunayPointsToCanvas","radius","renderVoronoiCellToCanvas","fillStyle","renderDebugToCanvas"],"mappings":"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"}