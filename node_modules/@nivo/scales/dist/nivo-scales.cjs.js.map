{"version":3,"file":"nivo-scales.cjs.js","sources":["../src/timeHelpers.ts","../src/linearScale.ts","../src/pointScale.ts","../src/bandScale.ts","../src/timeScale.ts","../src/logScale.ts","../src/symlogScale.ts","../src/compute.ts","../src/ticks.ts","../src/types.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { interpolateRound, interpolateNumber } from 'd3-interpolate'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const linearScaleDefaults: Required<ScaleLinearSpec> = {\n    type: 'linear',\n    min: 0,\n    max: 'auto',\n    stacked: false,\n    reverse: false,\n    clamp: false,\n    nice: true,\n    round: false,\n}\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = linearScaleDefaults.min,\n        max = linearScaleDefaults.max,\n        stacked = linearScaleDefaults.stacked,\n        reverse = linearScaleDefaults.reverse,\n        clamp = linearScaleDefaults.clamp,\n        nice = linearScaleDefaults.nice,\n        round = linearScaleDefaults.round,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? (data.minStacked ?? 0) : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? (data.maxStacked ?? 0) : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .interpolate(round ? interpolateRound : interpolateNumber)\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const bandScaleDefaults: Required<ScaleBandSpec> = {\n    type: 'band',\n    round: false,\n}\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = bandScaleDefaults.round }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const timeScaleDefaults: Required<ScaleTimeSpec> = {\n    type: 'time',\n    format: 'native',\n    precision: 'millisecond',\n    min: 'auto',\n    max: 'auto',\n    useUTC: true,\n    nice: false,\n}\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = timeScaleDefaults.format,\n        precision = timeScaleDefaults.precision,\n        min = timeScaleDefaults.min,\n        max = timeScaleDefaults.max,\n        useUTC = timeScaleDefaults.useUTC,\n        nice = timeScaleDefaults.nice,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const logScaleDefaults: Required<ScaleLogSpec> = {\n    type: 'log',\n    base: 10,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createLogScale = (\n    {\n        base = logScaleDefaults.base,\n        min = logScaleDefaults.min,\n        max = logScaleDefaults.max,\n        round = logScaleDefaults.round,\n        reverse = logScaleDefaults.reverse,\n        nice = logScaleDefaults.nice,\n    }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>().base(base)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    // @ts-expect-error not sure why this is not working, it's available for symlog.\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const symlogScaleDefaults: Required<ScaleSymlogSpec> = {\n    type: 'symlog',\n    constant: 1,\n    min: 'auto',\n    max: 'auto',\n    round: false,\n    reverse: false,\n    nice: true,\n}\n\nexport const createSymlogScale = (\n    {\n        constant = symlogScaleDefaults.constant,\n        min = symlogScaleDefaults.min,\n        max = symlogScaleDefaults.max,\n        round = symlogScaleDefaults.round,\n        reverse = symlogScaleDefaults.reverse,\n        nice = symlogScaleDefaults.nice,\n    }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>().constant(constant)\n\n    const range = axis === 'x' ? [0, size] : [size, 0]\n    if (round === true) scale.rangeRound(range)\n    else scale.range(range)\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq.js'\nimport uniqBy from 'lodash/uniqBy.js'\nimport sortBy from 'lodash/sortBy.js'\nimport last from 'lodash/last.js'\nimport isDate from 'lodash/isDate.js'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date | null\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date | null\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: readonly D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Exclude<Input, null>>(spec, data, size)\n        case 'band':\n            return createBandScale<Exclude<Input, null>>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\n/**\n * Band and point scales are not centered, meaning the ticks would\n * be positioned at the beginning of each step; however, we want\n * them to be centered for each step.\n */\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable,\n            // however, local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n","import {\n    ScaleLinear as D3ScaleLinear,\n    ScalePoint as D3ScalePoint,\n    ScaleBand as D3ScaleBand,\n    ScaleLogarithmic as D3ScaleLogarithmic,\n    ScaleSymLog as D3ScaleSymLog,\n    ScaleTime as D3ScaleTime,\n} from 'd3-scale'\nimport { TIME_PRECISION } from './timeHelpers'\n\nexport type ScaleAxis = 'x' | 'y'\nexport type OtherScaleAxis<Axis extends ScaleAxis> = Axis extends 'x' ? 'y' : 'x'\n\nexport type NumericValue = { valueOf(): number }\nexport type StringValue = { toString(): string }\nexport type ScaleValue = NumericValue | StringValue | Date | null\n\nexport interface ScaleTypeToSpec {\n    linear: ScaleLinearSpec\n    log: ScaleLogSpec\n    symlog: ScaleSymlogSpec\n    point: ScalePointSpec\n    band: ScaleBandSpec\n    time: ScaleTimeSpec\n}\n\nexport type ScaleType = keyof ScaleTypeToSpec\nexport type ScaleSpec = ScaleTypeToSpec[keyof ScaleTypeToSpec]\n\nexport type ReversibleScaleSpec = ScaleLinearSpec | ScaleLogSpec | ScaleSymlogSpec\n\nexport const isReversibleScaleSpec = (scaleSpec: ScaleSpec): scaleSpec is ReversibleScaleSpec => {\n    return scaleSpec.type === 'linear' || scaleSpec.type === 'log' || scaleSpec.type === 'symlog'\n}\n\nexport interface ScaleTypeToScale<Input, Output> {\n    linear: Input extends NumericValue ? ScaleLinear<Output> : never\n    log: Input extends NumericValue ? ScaleLog : never\n    symlog: Input extends NumericValue ? ScaleSymlog : never\n    point: Input extends StringValue ? ScalePoint<Input> : never\n    band: Input extends StringValue ? ScaleBand<Input> : never\n    time: Input extends StringValue | Date ? ScaleTime<Input> : never\n}\n\nexport type Scale<Input, Output> = ScaleTypeToScale<Input, Output>[keyof ScaleTypeToScale<\n    Input,\n    Output\n>]\n\nexport type ScaleLinearSpec = {\n    type: 'linear'\n    min?: 'auto' | number\n    max?: 'auto' | number\n    stacked?: boolean\n    reverse?: boolean\n    clamp?: boolean\n    nice?: boolean | number\n    round?: boolean\n}\nexport interface ScaleLinear<Output> extends D3ScaleLinear<number, Output, never> {\n    type: 'linear'\n    stacked: boolean\n}\n\nexport interface ScaleLogSpec {\n    type: 'log'\n    base?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleLog extends D3ScaleLogarithmic<number, number> {\n    type: 'log'\n}\n\nexport interface ScaleSymlogSpec {\n    type: 'symlog'\n    constant?: number\n    min?: 'auto' | number\n    max?: 'auto' | number\n    round?: boolean\n    reverse?: boolean\n    nice?: boolean | number\n}\nexport interface ScaleSymlog extends D3ScaleSymLog<number, number> {\n    type: 'symlog'\n}\n\nexport type ScalePointSpec = {\n    type: 'point'\n}\nexport interface ScalePoint<Input extends StringValue> extends D3ScalePoint<Input> {\n    type: 'point'\n}\n\nexport type ScaleBandSpec = {\n    type: 'band'\n    round?: boolean\n}\nexport interface ScaleBand<Input extends StringValue> extends D3ScaleBand<Input> {\n    type: 'band'\n}\n\nexport type ScaleTimeSpec = {\n    type: 'time'\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    min?: 'auto' | Date | string\n    max?: 'auto' | Date | string\n    useUTC?: boolean\n    nice?: boolean\n}\n\nexport interface ScaleTime<Input> extends D3ScaleTime<Input, number> {\n    type: 'time'\n    useUTC: boolean\n}\n\nexport type AnyScale = Scale<any, any>\n\nexport type ScaleWithBandwidth = ScaleBand<any> | ScalePoint<any>\n\nexport type Series<XValue extends ScaleValue, YValue extends ScaleValue> = {\n    data: {\n        data: {\n            x: XValue | null\n            y: YValue | null\n        }\n    }[]\n}[]\n\n// A serie containing data for a specific axis\nexport type SerieAxis<Axis extends ScaleAxis, Value extends ScaleValue> = {\n    data: {\n        data: Record<Axis, Value | null>\n    }[]\n}[]\n\nexport type ComputedSerieAxis<Value extends ScaleValue> = {\n    all: readonly Value[]\n    min: Value\n    minStacked?: Value\n    max: Value\n    maxStacked?: Value\n}\n\nexport type TicksSpec<Value extends ScaleValue> =\n    // exact number of ticks, please note that\n    // depending on the current range of values,\n    // you might not get this exact count\n    | number\n    // string is used for Date based scales,\n    // it can express a time interval,\n    // for example: every 2 weeks\n    | string\n    // override scale ticks with custom explicit values\n    | readonly Value[]\n"],"names":["precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","_ref","_ref$format","format","_ref$precision","_ref$useUTC","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","linearScaleDefaults","type","min","max","stacked","reverse","clamp","nice","round","createLinearScale","data","size","axis","minValue","_data$minStacked","maxValue","_data$maxStacked","_ref$min","_ref$max","_ref$stacked","_ref$reverse","_ref$clamp","_ref$nice","_ref$round","minStacked","maxStacked","scale","scaleLinear","range","interpolate","interpolateRound","interpolateNumber","domain","castLinearScale","typedScale","createPointScale","_spec","scalePoint","all","bandScaleDefaults","createBandScale","scaleBand","castBandScale","timeScaleDefaults","createTimeScale","normalize","scaleUtc","scaleTime","logScaleDefaults","base","createLogScale","sign","_ref$base","some","v","Error","hasMixedSign","filter","Math","scaleLog","rangeRound","symlogScaleDefaults","constant","createSymlogScale","_ref$constant","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","_scale","stackedValue","generateSeriesXY","series","xScaleSpec","yScaleSpec","x","generateSeriesAxis","y","scaleSpec","_temp","_ref$getValue","getValue","d","_ref$setValue","setValue","serie","parseFloat","String","values","push","sortBy","uniq","apply","uniqBy","sort","last","stackAxis","xy","otherAxis","compare","isDate","stack","find","stackValue","head","stackX","stackY","timeDay","timeInterval","step","getDate","start","end","floor","utcDay","setUTCHours","setUTCDate","getUTCDate","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","bandwidth","offset","width","height","nestedSeries","map","_extends","nestSerieData","xScale","yScale","computedSeries","position","Array","isArray","matches","match","amount","timeType","_timeType$every$range","_timeType$every","_scale$domain","originalStop","stop","every","Number","ticks","interval","isFinite"],"mappings":"keAcaA,EAA6C,CACtD,SAAAC,GAAI,OAAIA,EAAKC,gBAAgB,EAAE,EAC/B,SAAAD,GAAI,OAAIA,EAAKE,WAAW,EAAE,EAC1B,SAAAF,GAAI,OAAIA,EAAKG,WAAW,EAAE,EAC1B,SAAAH,GAAI,OAAIA,EAAKI,SAAS,EAAE,EACxB,SAAAJ,GAAI,OAAIA,EAAKK,QAAQ,EAAE,EACvB,SAAAL,GAAI,OAAIA,EAAKM,SAAS,EAAE,GAGfC,EAA2E,CACpFC,YAAa,GACbC,OAAQV,EAAiBW,MAAM,EAAG,GAClCC,OAAQZ,EAAiBW,MAAM,EAAG,GAClCE,KAAMb,EAAiBW,MAAM,EAAG,GAChCG,IAAKd,EAAiBW,MAAM,EAAG,GAC/BI,MAAOf,EAAiBW,MAAM,EAAG,GACjCK,KAAMhB,EAAiBW,MAAM,EAAG,IAGvBM,EAAwB,SAACC,GAAyB,OAAK,SAACjB,GAKjE,OAJAO,EAAuBU,GAAWC,SAAQ,SAAAC,GACtCA,EAAOnB,EACX,IAEOA,EACV,EAEYoB,EAAuB,SAAHC,GAQ3B,IAAAC,EAAAD,EAPFE,OAAAA,OAAS,IAAHD,EAAG,SAAQA,EAAAE,EAAAH,EACjBJ,UAAAA,OAAY,IAAHO,EAAG,cAAaA,EAAAC,EAAAJ,EACzBK,OAAAA,OAAS,IAAHD,GAAOA,EAMPE,EAAcX,EAAsBC,GAE1C,OAAO,SAACW,GACJ,QAAcC,IAAVD,EACA,OAAOA,EAGX,GAAe,WAAXL,GAAuBK,aAAiBE,KACxC,OAAOH,EAAYC,GAGvB,IAAMG,EAAYL,EAASM,EAAQA,SAACT,GAAUU,EAAAA,UAAUV,GACxD,OAAOI,EAAYI,EAAUH,IAErC,EC5DaM,EAAiD,CAC1DC,KAAM,SACNC,IAAK,EACLC,IAAK,OACLC,SAAS,EACTC,SAAS,EACTC,OAAO,EACPC,MAAM,EACNC,OAAO,GAGEC,EAAoB,SAAHtB,EAU1BuB,EACAC,EACAC,GACC,IACGC,EACgBC,EAMhBC,EACgBC,EATnBC,EAAA9B,EAXGe,IAAAA,OAAG,IAAAe,EAAGjB,EAAoBE,IAAGe,EAAAC,EAAA/B,EAC7BgB,IAAAA,OAAG,IAAAe,EAAGlB,EAAoBG,IAAGe,EAAAC,EAAAhC,EAC7BiB,QAAAA,OAAO,IAAAe,EAAGnB,EAAoBI,QAAOe,EAAAC,EAAAjC,EACrCkB,QAAAA,OAAO,IAAAe,EAAGpB,EAAoBK,QAAOe,EAAAC,EAAAlC,EACrCmB,MAAAA,OAAK,IAAAe,EAAGrB,EAAoBM,MAAKe,EAAAC,EAAAnC,EACjCoB,KAAAA,OAAI,IAAAe,EAAGtB,EAAoBO,KAAIe,EAAAC,EAAApC,EAC/BqB,MAAAA,OAAK,IAAAe,EAAGvB,EAAoBQ,MAAKe,EAOzB,SAARrB,EACAW,GAAuB,IAAZT,SAAgBU,EAAIJ,EAAKc,YAAUV,EAAI,EAAKJ,EAAKR,IAE5DW,EAAWX,EAIH,SAARC,EACAY,GAAuB,IAAZX,SAAgBY,EAAIN,EAAKe,YAAUT,EAAI,EAAKN,EAAKP,IAE5DY,EAAWZ,EAGf,IAAMuB,EAAQC,EAAWA,cACpBC,MAAe,MAAThB,EAAe,CAAC,EAAGD,GAAQ,CAACA,EAAM,IACxCkB,YAAYrB,EAAQsB,EAAAA,iBAAmBC,EAAAA,mBACvCC,OAAO3B,EAAU,CAACU,EAAUF,GAAY,CAACA,EAAUE,IACnDT,MAAMA,GAKX,OAHa,IAATC,EAAemB,EAAMnB,OACA,iBAATA,GAAmBmB,EAAMnB,KAAKA,GAEvC0B,EAAgBP,EAAOtB,EAClC,EAEa6B,EAAkB,SAC3BP,EACAtB,QAAO,IAAPA,IAAAA,GAAU,GAEV,IAAM8B,EAAaR,EAInB,OAHAQ,EAAWjC,KAAO,SAClBiC,EAAW9B,QAAUA,EAEd8B,CACX,EC7DaC,EAAmB,SAC5BC,EACA1B,EACAC,GAEA,IAEMuB,EAFQG,EAAAA,aAAoBT,MAAM,CAAC,EAAGjB,IAAOqB,OAAOtB,EAAK4B,KAK/D,OAFAJ,EAAWjC,KAAO,QAEXiC,CACX,ECXaK,EAA6C,CACtDtC,KAAM,OACNO,OAAO,GAGEgC,EAAkB,SAAHrD,EAExBuB,EACAC,EACAC,GACC,IAAAW,EAAApC,EAJCqB,MAAAA,OAAK,IAAAe,EAAGgB,EAAkB/B,MAAKe,EAK3BG,EAAQe,EAASA,YAClBb,MAAe,MAAThB,EAAe,CAAC,EAAGD,GAAQ,CAACA,EAAM,IACxCqB,OAAOtB,EAAK4B,KACZ9B,MAAMA,GAEX,OAAOkC,EAAqBhB,EAChC,EAEagB,EAAgB,SAA4BhB,GACrD,IAAMQ,EAAaR,EAGnB,OAFAQ,EAAWjC,KAAO,OAEXiC,CACX,ECvBaS,EAA6C,CACtD1C,KAAM,OACNZ,OAAQ,SACRN,UAAW,cACXmB,IAAK,OACLC,IAAK,OACLX,QAAQ,EACRe,MAAM,GAGGqC,EAAkB,SAAHzD,EASxBuB,EACAC,GACC,IAGGE,EASAE,EAZH3B,EAAAD,EATGE,OAAAA,OAAM,IAAAD,EAAGuD,EAAkBtD,OAAMD,EAAAE,EAAAH,EACjCJ,UAAAA,OAAS,IAAAO,EAAGqD,EAAkB5D,UAASO,EAAA2B,EAAA9B,EACvCe,IAAAA,OAAG,IAAAe,EAAG0B,EAAkBzC,IAAGe,EAAAC,EAAA/B,EAC3BgB,IAAAA,OAAG,IAAAe,EAAGyB,EAAkBxC,IAAGe,EAAA3B,EAAAJ,EAC3BK,OAAAA,OAAM,IAAAD,EAAGoD,EAAkBnD,OAAMD,EAAA+B,EAAAnC,EACjCoB,KAAAA,OAAI,IAAAe,EAAGqB,EAAkBpC,KAAIe,EAK3BuB,EAAY3D,EAAqB,CAAEG,OAAAA,EAAQN,UAAAA,EAAWS,OAAAA,IAIxDqB,EADQ,SAARX,EACW2C,EAAUnC,EAAKR,KACR,WAAXb,EACIwD,EAAU3C,GAEVA,EAKXa,EADQ,SAARZ,EACW0C,EAAUnC,EAAKP,KACR,WAAXd,EACIwD,EAAU1C,GAEVA,EAGf,IAAMuB,EAAQlC,EAASsD,aAAaC,EAASA,YAE7CrB,EAAME,MAAM,CAAC,EAAGjB,IAEZE,GAAYE,GAAUW,EAAMM,OAAO,CAACnB,EAAUE,KAErC,IAATR,EAAemB,EAAMnB,OACA,iBAATA,GAAqC,iBAATA,GAAmBmB,EAAMnB,KAAKA,GAE1E,IAAM2B,EAAaR,EAKnB,OAHAQ,EAAWjC,KAAO,OAClBiC,EAAW1C,OAASA,EAEb0C,CACX,EC1Dac,EAA2C,CACpD/C,KAAM,MACNgD,KAAM,GACN/C,IAAK,OACLC,IAAK,OACLK,OAAO,EACPH,SAAS,EACTE,MAAM,GAGG2C,EAAiB,SAAH/D,EASvBuB,EACAC,EACAC,GACC,IAMGuC,EANHC,EAAAjE,EAVG8D,KAAAA,OAAI,IAAAG,EAAGJ,EAAiBC,KAAIG,EAAAnC,EAAA9B,EAC5Be,IAAAA,OAAG,IAAAe,EAAG+B,EAAiB9C,IAAGe,EAAAC,EAAA/B,EAC1BgB,IAAAA,OAAG,IAAAe,EAAG8B,EAAiB7C,IAAGe,EAAAK,EAAApC,EAC1BqB,MAAAA,OAAK,IAAAe,EAAGyB,EAAiBxC,MAAKe,EAAAH,EAAAjC,EAC9BkB,QAAAA,OAAO,IAAAe,EAAG4B,EAAiB3C,QAAOe,EAAAE,EAAAnC,EAClCoB,KAAAA,OAAI,IAAAe,EAAG0B,EAAiBzC,KAAIe,EAOhC,GADgBZ,EAAK4B,IAAIe,MAAK,SAAAC,GAAC,OAAU,IAANA,KAE/B,MAAM,IAAIC,MAAK,qDAInB,IAgBI1C,EAOAE,EAvBAyC,GAAe,EAYnB,GAXA9C,EAAK4B,IACAmB,QAAO,SAAAH,GAAC,OAAS,MAALA,CAAS,IACrBtE,SAAQ,SAAAsE,GACDE,SACS7D,IAATwD,EACAA,EAAOO,KAAKP,KAAKG,GACVI,KAAKP,KAAKG,KAAOH,IACxBK,GAAe,GAEvB,IAEAA,EACA,MAAM,IAAID,MAAK,qEAKf1C,EADQ,SAARX,EACWQ,EAAKR,IAELA,EAKXa,EADQ,SAARZ,EACWO,EAAKP,IAELA,EAGf,IAAMuB,EAAQiC,EAAQA,WAAmBV,KAAKA,GAExCrB,EAAiB,MAAThB,EAAe,CAAC,EAAGD,GAAQ,CAACA,EAAM,IAClC,IAAVH,EAAgBkB,EAAMkC,WAAWhC,GAChCF,EAAME,MAAMA,IAED,IAAZvB,EAAkBqB,EAAMM,OAAO,CAACjB,EAAUF,IACzCa,EAAMM,OAAO,CAACnB,EAAUE,KAEhB,IAATR,EAAemB,EAAMnB,OAEA,iBAATA,GAAmBmB,EAAMnB,KAAKA,GAE9C,IAAM2B,EAAaR,EAGnB,OAFAQ,EAAWjC,KAAO,MAEXiC,CACX,EC5Ea2B,EAAiD,CAC1D5D,KAAM,SACN6D,SAAU,EACV5D,IAAK,OACLC,IAAK,OACLK,OAAO,EACPH,SAAS,EACTE,MAAM,GAGGwD,EAAoB,SAAH5E,EAS1BuB,EACAC,EACAC,GACC,IACGC,EAOAE,EARHiD,EAAA7E,EAVG2E,SAAAA,OAAQ,IAAAE,EAAGH,EAAoBC,SAAQE,EAAA/C,EAAA9B,EACvCe,IAAAA,OAAG,IAAAe,EAAG4C,EAAoB3D,IAAGe,EAAAC,EAAA/B,EAC7BgB,IAAAA,OAAG,IAAAe,EAAG2C,EAAoB1D,IAAGe,EAAAK,EAAApC,EAC7BqB,MAAAA,OAAK,IAAAe,EAAGsC,EAAoBrD,MAAKe,EAAAH,EAAAjC,EACjCkB,QAAAA,OAAO,IAAAe,EAAGyC,EAAoBxD,QAAOe,EAAAE,EAAAnC,EACrCoB,KAAAA,OAAI,IAAAe,EAAGuC,EAAoBtD,KAAIe,EAQ/BT,EADQ,SAARX,EACWQ,EAAKR,IAELA,EAKXa,EADQ,SAARZ,EACWO,EAAKP,IAELA,EAGf,IAAMuB,EAAQuC,EAAWA,cAAmBH,SAASA,GAE/ClC,EAAiB,MAAThB,EAAe,CAAC,EAAGD,GAAQ,CAACA,EAAM,IAClC,IAAVH,EAAgBkB,EAAMkC,WAAWhC,GAChCF,EAAME,MAAMA,IAED,IAAZvB,EAAkBqB,EAAMM,OAAO,CAACjB,EAAUF,IACzCa,EAAMM,OAAO,CAACnB,EAAUE,KAEhB,IAATR,EAAemB,EAAMnB,OACA,iBAATA,GAAmBmB,EAAMnB,KAAKA,GAE9C,IAAM2B,EAAaR,EAGnB,OAFAQ,EAAWjC,KAAO,SAEXiC,CACX,ECFagC,EAAe,SAACtD,GAAe,MAA0B,MAATA,EAAe,IAAM,GAAG,EAExEuD,EAAgB,SAACC,EAAoBC,GAAkB,OAAKD,IAAMC,CAAC,EACnEC,EAAoB,SAACF,EAASC,GAAO,OAAKD,EAAEG,YAAcF,EAAEE,SAAS,EAE3E,SAASC,EACZC,EACA/D,EACAC,EACAC,GAEA,OAAQ6D,EAAKxE,MACT,IAAK,SACD,OAAOQ,EAAkBgE,EAAM/D,EAAMC,EAAMC,GAC/C,IAAK,QACD,OAAOuB,EAAuCsC,EAAM/D,EAAMC,GAC9D,IAAK,OACD,OAAO6B,EAAsCiC,EAAM/D,EAAMC,EAAMC,GACnE,IAAK,OACD,OAAOgC,EAAgB6B,EAAM/D,EAAMC,GACvC,IAAK,MACD,OAAOuC,EAAeuB,EAAM/D,EAAMC,EAAMC,GAC5C,IAAK,SACD,OAAOmD,EAAkBU,EAAM/D,EAAMC,EAAMC,GAC/C,QACI,MAAM,IAAI2C,MAAM,sBAE5B,CASA,IAOMmB,EAAuB,SACzBC,EACA/D,EACAc,GACgB,IAAAkD,EAChB,GAAI,YAAalD,GAASA,EAAMtB,QAAS,CACrC,IAAMyE,EAAeF,EAAMjE,KAAc,MAATE,EAAe,WAAa,YAC5D,OAAIiE,QACO,KAGJnD,EAAMmD,EACjB,CAEA,OAA8BD,OAA9BA,EAAOlD,EAAMiD,EAAMjE,KAAKE,KAAMgE,EAAI,IACtC,EAwDaE,EAAmB,SAC5BC,EACAC,EACAC,GAAqB,MACnB,CACFC,EAAGC,EAAgCJ,EAAQ,IAAKC,GAChDI,EAAGD,EAAgCJ,EAAQ,IAAKE,GACnD,EAMYE,EAAqB,SAC9BJ,EACAnE,EACAyE,EAAoBC,GAUnB,IAAAnG,WAAAmG,EADG,CAAE,EAAAA,EAAAC,EAAApG,EAPFqG,SAAAA,OAAW,IAAHD,EAAG,SAAAE,GAAC,OAAIA,EAAE/E,KAAKE,EAAK,EAAA2E,EAAAG,EAAAvG,EAC5BwG,SAAAA,OAAQ,IAAAD,EAAG,SAACD,EAAGnC,GACXmC,EAAE/E,KAAKE,GAAQ0C,CAClB,EAAAoC,EAML,GAAuB,WAAnBL,EAAUpF,KACV8E,EAAO/F,SAAQ,SAAA4G,GACXA,EAAMlF,KAAK1B,SAAQ,SAAAyG,GACf,IAAM/F,EAAQ8F,EAASC,GAEnB/F,GACAiG,EAASF,EAAGI,WAAWC,OAAOpG,IAEtC,GACJ,SACG,GAAuB,SAAnB2F,EAAUpF,MAAwC,WAArBoF,EAAUhG,OAAqB,CAGnE,IAAMQ,EAAYX,EAAqBmG,GAEvCN,EAAO/F,SAAQ,SAAA4G,GACXA,EAAMlF,KAAK1B,SAAQ,SAAAyG,GACf,IAAM/F,EAAQ8F,EAASC,GAEnB/F,GACAiG,EAASF,EAAG5F,EAAUH,GAE9B,GACJ,GACJ,CAEA,IAAMqG,EAAoB,GAQ1B,OANAhB,EAAO/F,SAAQ,SAAA4G,GACXA,EAAMlF,KAAK1B,SAAQ,SAAAyG,GACfM,EAAOC,KAAKR,EAASC,GACzB,GACJ,IAEQJ,EAAUpF,MACd,IAAK,SACD,IAAMqC,EAAM2D,EAERC,EAAKH,GAAoBtC,QAAO,SAAAH,GAAC,OAAU,OAANA,MACrC,SAAAA,GAAC,OAAIA,CAAC,IAGV,MAAO,CAAEhB,IAAAA,EAAKpC,IAAKwD,KAAKxD,IAAGiG,MAARzC,KAAYpB,GAAMnC,IAAKuD,KAAKvD,IAAGgG,MAARzC,KAAYpB,IAE1D,IAAK,OACD,IAAMA,EAAM8D,EAAOL,GAAkB,SAAAzC,GAAC,OAAIA,EAAEiB,aACvC/F,MAAM,GACN6H,MAAK,SAACjC,EAAGC,GAAC,OAAKA,EAAEE,UAAYH,EAAEG,aAC/BlE,UAEL,MAAO,CAAEiC,IAAAA,EAAKpC,IAAKoC,EAAI,GAAInC,IAAKmG,EAAKhE,IAEzC,QACI,IAAMA,EAAM4D,EAAKH,GAEjB,MAAO,CAAEzD,IAAAA,EAAKpC,IAAKoC,EAAI,GAAInC,IAAKmG,EAAKhE,IAGjD,EAEaiE,EAAY,SACrB3F,EACA4F,EACAzB,GAEA,IAAM0B,EAAYvC,EAAatD,GACzB0B,EAAgB,GAEtBkE,EAAGC,GAAWnE,IAAItD,SAAQ,SAAAsE,GACtB,IAAMoD,EAAWC,EAAOrD,GAAKgB,EAAoBH,EAC3CyC,EAA8B,GAEpC7B,EAAO/F,SAAQ,SAAA4G,GACX,IAAMjB,EAAQiB,EAAMlF,KAAKmG,MAAK,SAAApB,GAAC,OAAIiB,EAAQjB,EAAE/E,KAAK+F,GAAYnD,MAC1D5D,EAAQ,KACRoH,EAAa,KAEjB,QAAcnH,IAAVgF,EAAqB,CAGrB,GAAc,QADdjF,EAAQiF,EAAMjE,KAAKE,IACC,CAChB,IAAMmG,EAAOT,EAAKM,QACLjH,IAAToH,EACAD,EAAapH,EACG,OAATqH,IACPD,EAAaC,EAAOrH,EAE5B,CAEAiF,EAAMjE,KAAc,MAATE,EAAe,WAAa,YAAckG,CACzD,CAEAF,EAAMZ,KAAKc,GAEQ,OAAfA,GACAxE,EAAI0D,KAAKc,EAEjB,GACJ,IAEAN,EAAG5F,GAAMY,WAAakC,KAAKxD,IAAGiG,MAARzC,KAAYpB,GAClCkE,EAAG5F,GAAMa,WAAaiC,KAAKvD,IAAGgG,MAARzC,KAAYpB,EACtC,EAEM0E,EAAS,SACXR,EACAzB,GAA2B,OAC1BwB,EAAgB,IAAKC,EAAIzB,EAAO,EAE/BkC,EAAS,SACXT,EACAzB,GAA2B,OAC1BwB,EAAgB,IAAKC,EAAIzB,EAAO,EC/P/BmC,EAAUC,EAAAA,cACZ,SAAArJ,GAAI,OAAIA,EAAKI,SAAS,EAAG,EAAG,EAAG,EAAE,IACjC,SAACJ,EAAMsJ,GAAI,OAAKtJ,EAAKK,QAAQL,EAAKuJ,UAAYD,EAAK,IACnD,SAACE,EAAOC,GAAG,OAAMA,EAAIhD,UAAY+C,EAAM/C,WAAa,KAAK,IACzD,SAAAzG,GAAI,OAAI4F,KAAK8D,MAAM1J,EAAKyG,UAAY,MAAM,IAGxCkD,EAASN,EAAAA,cACX,SAAArJ,GAAI,OAAIA,EAAK4J,YAAY,EAAG,EAAG,EAAG,EAAE,IACpC,SAAC5J,EAAMsJ,GAAI,OAAKtJ,EAAK6J,WAAW7J,EAAK8J,aAAeR,EAAK,IACzD,SAACE,EAAOC,GAAG,OAAMA,EAAIhD,UAAY+C,EAAM/C,WAAa,KAAK,IACzD,SAAAzG,GAAI,OAAI4F,KAAK8D,MAAM1J,EAAKyG,UAAY,MAAM,IAGxCsD,EAA6E,CAC/EvJ,YAAa,CAACwJ,EAAeA,gBAAEC,kBAC/BxJ,OAAQ,CAACyJ,EAAUA,WAAEC,aACrBxJ,OAAQ,CAACyJ,EAAUA,WAAEC,aACrBzJ,KAAM,CAAC0J,EAAQA,SAAEC,WACjB1J,IAAK,CAACuI,EAASO,GACfa,KAAM,CAACC,EAAQA,SAAEC,WACjBC,OAAQ,CAACC,EAAUA,WAAEC,aACrBC,OAAQ,CAACC,EAAUA,WAAEC,aACrBC,QAAS,CAACC,EAAWA,YAAEC,cACvBC,UAAW,CAACC,EAAaA,cAAEC,gBAC3BC,SAAU,CAACC,EAAYA,aAAEC,eACzBC,OAAQ,CAACC,EAAUA,WAAEC,aACrBC,SAAU,CAACC,EAAYA,aAAEC,eACzBjL,MAAO,CAACkL,EAASA,UAAEC,YACnBlL,KAAM,CAACmL,EAAQA,SAAEC,YAGfC,EAAYC,OAAOC,KAAKvC,GACxBwC,EAAqB,IAAIC,OAAgCJ,yBAAAA,EAAUK,KAAK,KAAI,OAAQ,0GNrE5D,SAA4B7I,GACtD,IAAMQ,EAAaR,EAGnB,OAFAQ,EAAWjC,KAAO,QAEXiC,CACX,sBMkB2B,SAAQR,GAC/B,IAAM8I,EAAY9I,EAAM8I,YAExB,GAAkB,IAAdA,EAAiB,OAAO9I,EAE5B,IAAI+I,EAASD,EAAY,EAKzB,OAJI9I,EAAMlB,UACNiK,EAAS/G,KAAKlD,MAAMiK,IAGjB,SAAkBhF,GAAI,IAAAb,EAAA,OAAc,OAATA,EAAClD,EAAM+D,IAAEb,EAAI,GAAK6F,CAAM,CAC9D,8GDuEwC,SACpC1F,EACAC,EACAC,EACAyF,EACAC,GAGA,IAAMC,EAAe7F,EAAO8F,KAAI,SAAAjF,GAAK,OAvCnB,SAClBA,GAAkB,OAAAkF,KAEflF,EAAK,CACRlF,KAAMkF,EAAMlF,KAAKmK,KAAI,SAAApF,GAAC,MAAK,CAAE/E,KAAIoK,EAAA,CAAA,EAAOrF,QAAO,CAmCNsF,CAAoBnF,MAGvDY,EAAK1B,EAAuB8F,EAAc5F,EAAYC,GAGxD,YAAaD,IAAqC,IAAvBA,EAAW5E,SACtC4G,EAAaR,EAAiBoE,GAI9B,YAAa3F,IAAqC,IAAvBA,EAAW7E,SACtC6G,EAAaT,EAAiBoE,GAIlC,IAAMI,EAASxG,EAAqBQ,EAAYwB,EAAGtB,EAAGwF,EAAO,KACvDO,EAASzG,EAAqBS,EAAYuB,EAAGpB,EAAGuF,EAAQ,KAGxDO,EAAwCN,EAAaC,KAAI,SAAAjF,GAAK,OAAAkF,KAC7DlF,EAAK,CACRlF,KAAMkF,EAAMlF,KAAKmK,KAAI,SAAAlG,GAAK,OAAAmG,KACnBnG,EAAK,CACRwG,SAAU,CACNjG,EAAGR,EAAqBC,EAAO,IAAKqG,GACpC5F,EAAGV,EAAqBC,EAAO,IAAKsG,UAEzC,IAGP,OAAAH,KACOtE,EAAE,CACLzB,OAAQmG,EACRF,OAAAA,EACAC,OAAAA,GAER,sUC5E6B,SACzBvJ,EACA+C,GAGA,GAAI2G,MAAMC,QAAQ5G,GACd,OAAOA,EAGX,GAAoB,iBAATA,GAAqB,WAAY/C,EAAO,CAE/C,IAAM4J,EAAU7G,EAAK8G,MAAMlB,GAE3B,GAAIiB,EAAS,CACT,IAASE,EAAgBF,EAAO,GAAfrL,EAAQqL,EAAO,GAI1BG,EAAW5D,EAAW5H,GAAMyB,EAAMlC,OAAS,EAAI,GAErD,GAAa,QAATS,EAAgB,CAAA,IAAAyL,EAAAC,EAChBC,EAA8BlK,EAAMM,SAA7BsF,EAAKsE,EAAA,GAAEC,EAAYD,EAAA,GACpBE,EAAO,IAAIlM,KAAKiM,GAKtB,OAFAC,EAAK3N,QAAQ2N,EAAKzE,UAAY,GAEgCqE,OAA9DA,EAA0C,OAA1CC,EAAOF,EAASM,MAAMC,OAAa,MAANR,EAAAA,EAAU,UAAG,EAAnCG,EAAqC/J,MAAM0F,EAAOwE,IAAKJ,EAAI,EACtE,CAEA,QAAe/L,IAAX6L,EACA,OAAO9J,EAAMuK,MAAMR,GAGvB,IAAMS,EAAWT,EAASM,MAAMC,OAAOR,IAEvC,GAAIU,EACA,OAAOxK,EAAMuK,MAAMC,EAE3B,CAEA,MAAM,IAAI3I,MAA6BkB,uBAAAA,EAC3C,CAGA,GAAI,UAAW/C,EAAO,CAElB,QAAa/B,IAAT8E,EACA,OAAO/C,EAAMuK,QAIjB,GAtDa,iBADFvM,EAuDG+E,IAtDW0H,SAASzM,IAAUgE,KAAK8D,MAAM9H,KAAWA,EAuD9D,OAAOgC,EAAMuK,MAAMxH,EAE3B,CA1Dc,IAAC/E,EA6Df,OAAOgC,EAAMM,QACjB,gCCtHqC,SAACqD,GAClC,MAA0B,WAAnBA,EAAUpF,MAAwC,QAAnBoF,EAAUpF,MAAqC,WAAnBoF,EAAUpF,IAChF,gMT/B8B,CAC1B,cACA,SACA,SACA,OACA,MACA,QACA"}